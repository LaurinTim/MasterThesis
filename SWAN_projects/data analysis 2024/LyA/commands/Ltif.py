#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import label, find_objects, center_of_mass
from PIL import Image
from pathlib import Path
import os
from tqdm import tqdm
import time
from ast import literal_eval


# In[2]:


class Lpic:
    '''
    
    evaluate a single tif file generated by MCP5
    
    '''
    
    def __init__(self, file, thresh = None):
        '''
        
        self.file is the path of the file we are looking at
        self.im opens the file
        self.arr is a numpy array containing the info of the file
        self.thresh is the threshold we set above which elements are considered to be part of a cluster
            if there is no specific input, the threshold is set at the average of all the data + 3 times its standard deviation
        self.ca is the same as self.arr but every element below self.thresh is set to 0
        
        '''
        self.file = file
        self.im = Image.open(self.file)
        self.arr = np.array(self.im)
        self.thresh = thresh if thresh != None else (np.average(self.arr) + 3 * np.std(self.arr))
        self.ca = self.arr.copy()
        self.ca[self.ca < self.thresh] = 0
    
    
    def get_clus(self, min_size = 5, min_sum = 0):
        '''
        
        get all the clusters in a tif file
        
        Parameters
        ------------
        min_size = 5 the minimum size a cluster has to be
        min_sum = 0 the minimum sum of the elements in a cluster

        Returns
        ------------
        df = dataframe with the columns:
            cluster = matrix which contains the cluster shape
            pos = position in self.mat of upper left element of the cluter shape
            size = cluster size
            sum = sum of elements in the cluster
            coords = coordinates of elements in cluster

        '''
        mat = self.ca.copy()

        clus = []
        pos = []
        center = []
        size = []
        tot = []
        coords = []

        struc = np.array([[1,1,1],[1,1,1],[1,1,1]]) * 0.1
        mat_labeled, num = label(mat, structure = struc)
        clust_slices = find_objects(mat_labeled)

        '''
        for i in range(num):
            temp_clus = mat[clust_slices[i]]
            temp_size = len([val for bal in temp_clus for val in bal if val > 0])
            if (temp_size >= min_size):
                size += [int(temp_size)]
                clus += [temp_clus.tolist()]
                pos += [[clust_slices[i][0].start, clust_slices[i][1].start]]
                center += [list(center_of_mass(temp_clus))]
                tot += [sum(sum(temp_clus))]
                coords += [np.asarray(np.nonzero(temp_clus)).tolist()]'''
        
        for i in range(num):
            temp_clus = mat[clust_slices[i]]
            temp_lab = mat_labeled[clust_slices[i]].tolist()
            temp_lab = [[val if val == i + 1 else 0 for val in bal] for bal in temp_lab]
            temp_size = len([val for bal in temp_lab for val in bal if val == i + 1])
            temp_tot = sum(sum(temp_clus))
            if temp_size >= min_size and temp_tot >= min_sum:
                size += [int(temp_size)]
                clus += [temp_clus.tolist()]
                pos += [[clust_slices[i][0].start, clust_slices[i][1].start]]
                center += [list(center_of_mass(temp_clus))]
                tot += [temp_tot]
                coords += [np.asarray(np.nonzero(temp_lab)).tolist()]

        df = pd.DataFrame([clus,pos,center,size,tot,coords], index = ['cluster', 'pos', 'center', 'size', 'sum', 'coords']).transpose()

        return df
    
    def show_clust(self, min_size = 5, min_sum = 0, ran = None):
        '''
        
        display one or multiple clusters
        
        Parameters
        ------------
        min_size = the minimum size a cluster has to be
        min_sum = 0 the minimum sum of the elements in a cluster
        ran = int or tuple, if ran is an int, the corresponding cluster will be displayed, if ran is a list, then the clusters from ran[0] to ran[1] - 1 will be displayed
        
        '''
        df = self.get_clus(min_size = min_size, min_sum = min_sum)
        
        ran = ran if ran != None else [0, len(df)]
        
        #if ran is an int we just display the corresponding cluster
        if type(ran) == int:
            curr = df.iloc[ran]
            height = len(curr[0])
            wid = len(curr[0][0])
            cpos = curr[1]
            plt.figure(figsize = (10,10))
            plt.imshow(self.ca[cpos[0] - 1:cpos[0] + height + 1, cpos[1] - 1:cpos[1] + wid + 1])
            plt.scatter([val + 1 for val in curr[5][1]], [val + 1 for val in curr[5][0]], s = 200, label = 'elements that are part of the cluster')
            plt.scatter(curr[2][1] + 1, curr[2][0] + 1, s = 200, color = 'red', label = 'weighted center of the cluster')
            plt.title(label = '%1.0fth cluster from the file' % (ran))
            plt.legend(loc = 'best', markerscale = 0.4)
            return
        
        for i in np.arange(ran[0], ran[1]):
            curr = df.iloc[i]
            height = len(curr[0])
            wid = len(curr[0][0])
            cpos = curr[1]
            plt.figure(figsize = (5,5))
            plt.imshow(self.ca[cpos[0] - 1:cpos[0] + height + 1, cpos[1] - 1:cpos[1] + wid + 1], cmap = 'hot')
            plt.scatter([val + 1 for val in curr[5][1]], [val + 1 for val in curr[5][0]], s = 20, label = 'elements that are part of the cluster')
            plt.scatter(curr[2][1] + 1, curr[2][0] + 1, s = 20, color = 'red', label = 'weighted center of the cluster')
            plt.title(label = '%1.0fth cluster from the file' % (i))
            plt.legend(loc = 'best', markerscale = 0.4)
            
        return
          


# In[3]:


class Lpicday:
    '''
    
    class to evaluate all the tif files from the MCP5 from a day
    
    Parameters
    ------------
    date = yy_mm_dd day for which we want to evaluate the files
    
    '''
    
    
    def __init__(self, date):
        self.date = date
        
    
    def get_filelist(self):
        '''
        get a list with all the filenames for the pictures
        
        Returns
        ------------
        fl = list with names of all files
        
        '''
        if self.date[:2] == '23': datapath = Path('/eos/experiment/gbar/pgunpc/data/2023/' + self.date)
        
        else: datapath = Path('/eos/experiment/gbar/pgunpc/data/' + self.date) #path to the folder with the tif files
        
        fl = [val for val in os.listdir(datapath) if val.endswith('.tif') and val.startswith('PCO')] #only take filenames that start wich PCO
        
        return fl
    
    
    def get_filepaths(self):
        '''
        get a list with the paths to all the picture files
        
        Returns
        ------------
        fp = list with paths to all files
        
        '''
        fl = self.get_filelist()
        
        if self.date[:2] == '23': fp = ['/eos/experiment/gbar/pgunpc/data/2023/' + self.date + '/' + val for val in fl]
        
        else: fp = ['/eos/experiment/gbar/pgunpc/data/' + self.date + '/' + val for val in fl]
        
        return fp
    
    
    def clusters_day(self, min_size = 5):
        '''
        
        Get the data for all the cluster from a day in a pandas dataframe
        
        Parameters
        ------------
        min_size = the minimum size a cluster has to be
        ran = int or tuple, if ran is an int, the corresponding cluster will be displayed, if ran is a list, then the clusters from ran[0] to ran[1] - 1 will be displayed
        
        Returns
        ------------
        df = dataframe that has the same length as the number of tif files for the current day. df is structured in the way that for each file there is 1 row in which all the data from the clusters will be put into arrays. $
            The columns of the dataframe are:
                file = path to the current file
                cluster = list that contains 2d lists that each contain the form of a cluster for the corresponding file
                pos = list that contains the position of the top left corner of the corresponding cluster in the original image matrix
                center = coordinates of the weighted center for each cluster (these coordinates are not in the image matrix but in the cluster itself)
                size = list with the number of elements in each cluster
                sum = list containing the sum of all the elements in the corresponding cluster
                coords = coordinates of elements in each cluster
        
        '''
        #we construct the dataframe in the end with these lists
        file = self.get_filepaths()
        cluster = []
        pos = []
        center = []
        size = []
        summ = []
        coords = []
        for i in tqdm(file, total = len(file)):
            temp_data = Lpic(i).get_clus(min_size = min_size)
            cluster += [temp_data['cluster'].tolist()]
            pos += [temp_data['pos'].tolist()]
            center +=[temp_data['center'].tolist()]
            size += [temp_data['size'].tolist()]
            summ += [temp_data['sum'].tolist()]
            coords += [temp_data['coords'].tolist()]
            
        df = pd.DataFrame([file, cluster, pos, center, size, summ, coords], index = ['file', 'cluster', 'pos', 'center', 'size', 'sum', 'coords'])
        df = df.transpose()
        
        return df
    
    
    def clusters_data(self):
        '''
        
        save the data for the cluster from the current day into a textfile at /eos/user/l/lkoller/GBAR/data24/datasummary24/self.date/LyA_data
        
        '''
        CLUSFILE = Path('/eos') / 'user' / 'l' / 'lkoller' / 'GBAR' / 'data24' / 'datasummary24' / self.date / 'LyA_data'
        
        #make sure that there are files to use for the current date
        if len(self.get_filepaths()) == 0:
            return print('There are no MCP5 tif file for ' + self.date + '.')
        
        #check if the file already exists
        if ((CLUSFILE / ('clusters_' + self.date + '.npy')).is_file() == True):
            print('The clusters datafile for the date ' + self.date + ' already exists.')
            return self.read()
        
        #create a folder for the current date if it does not already exist
        if not (Path('/eos') / 'user' / 'l' / 'lkoller' / 'GBAR' / 'data24' / 'datasummary24' / self.date).exists():
            Path.mkdir(Path('/eos') / 'user' / 'l' / 'lkoller' / 'GBAR' / 'data24' / 'datasummary24' / self.date)
            
        #create the LyA_data folder if it does not already exist
        if not (CLUSFILE).exists():
            Path.mkdir(CLUSFILE)

        df = self.clusters_day(min_size = 5)
        
        np.save(CLUSFILE / ('clusters_' + self.date ), df)
                
        return self.read()
    
    
    def read(self, min_size = 5):
        '''
        
        read the csv file and get a pandas dataframe with the correct types for the columns
        
        '''
        CLUSFILE = Path('/eos') / 'user' / 'l' / 'lkoller' / 'GBAR' / 'data24' / 'datasummary24' / self.date / 'LyA_data'
                
        df = pd.DataFrame(np.load(str(CLUSFILE / ('clusters_' + self.date + '.npy')), allow_pickle = True), columns = ['MCP5', 'cluster', 'pos', 'center', 'size', 'sum', 'coords'])
        
        df = df.fillna('None')
        df = df.replace('NaN', 'None')
        
        if min_size > 5:
            for i in range(len(df)):
                keep = np.zeros(len(df['size'][i]))
                for k in range(len(df['size'][i])):
                    if df['size'][i][k] > min_size:
                        keep[k] = 1
                df['cluster'][i] = [val for val,bal in zip(df['cluster'][i],keep) if bal == 1]
                df['pos'][i] = [val for val,bal in zip(df['pos'][i],keep) if bal == 1]
                df['center'][i] = [val for val,bal in zip(df['center'][i],keep) if bal == 1]
                df['size'][i] = [val for val,bal in zip(df['size'][i],keep) if bal == 1]
                df['sum'][i] = [val for val,bal in zip(df['sum'][i],keep) if bal == 1]
                df['coords'][i] = [val for val,bal in zip(df['coords'][i],keep) if bal == 1]
        
        return df
